import{D as n}from"./DocsCallout-BQR4CNYn.js";import{D as o}from"./DocsFeatureItem-CBOFICTF.js";import{D as f,a as b}from"./DocsPageHeader-64RWP-14.js";import{u as p}from"./useDocHeadings-gQYepUus.js";import{d as u,i as m,c as v,b as a,a as t,k as d,w as i,m as s,o as c}from"./index-D3jXmUN6.js";import{_ as g}from"./_plugin-vue_export-helper-DlAUqK2U.js";const h={class:"docs-article"},y={class:"docs-content"},w={class:"docs-feature-list"},z={class:"docs-feature-list"},S={class:"docs-feature-list"},j=u({__name:"ProfilesHeapDumpAnalysisSectionPage",setup(D){const{setHeadings:r}=p(),l=[{id:"overview",text:"Overview",level:2},{id:"initialization",text:"Heap Dump Initialization",level:2},{id:"analysis",text:"Analysis Features",level:2},{id:"details",text:"Details",level:2}];return m(()=>{r(l)}),(k,e)=>(c(),v("article",h,[a(f,{title:"Heap Dump Analysis Section",icon:"bi bi-database"}),t("div",y,[e[10]||(e[10]=d('<p data-v-d4486fb7>The Heap Dump Analysis section provides <strong data-v-d4486fb7>memory analysis from heap dumps</strong>. This enables deep inspection of the Java heap at a specific point in time, including object instances, memory consumption, and reference chains.</p><h2 id="overview" data-v-d4486fb7>Overview</h2><p data-v-d4486fb7>Heap dump analysis differs from other profile analysis in that it examines a snapshot of memory rather than events over time:</p><ul data-v-d4486fb7><li data-v-d4486fb7><strong data-v-d4486fb7>Object inspection</strong> - See all objects in memory by class</li><li data-v-d4486fb7><strong data-v-d4486fb7>Memory sizing</strong> - Understand shallow vs retained sizes</li><li data-v-d4486fb7><strong data-v-d4486fb7>Reference analysis</strong> - Find what&#39;s keeping objects alive</li><li data-v-d4486fb7><strong data-v-d4486fb7>Custom queries</strong> - Use OQL for advanced investigation</li></ul>',4)),a(n,{type:"info"},{default:i(()=>[...e[0]||(e[0]=[t("strong",null,"Heap dump required:",-1),s(" This section requires a heap dump file (.hprof) to be associated with the profile. Features remain disabled until a heap dump is loaded and its cache is initialized. ",-1)])]),_:1}),e[11]||(e[11]=t("h2",{id:"initialization"},"Heap Dump Initialization",-1)),e[12]||(e[12]=t("p",null,"Before heap dump analysis features become available, the heap dump cache must be initialized:",-1)),t("div",w,[a(o,{icon:"bi bi-memory",title:"Heap Dump Overview"},{default:i(()=>[...e[1]||(e[1]=[s(" Shows the heap dump file information and initialization status. This page is always accessible and displays whether the cache is being built, ready, or if initialization failed. ",-1)])]),_:1})]),e[13]||(e[13]=d("<h3 data-v-d4486fb7>Initialization Process</h3><p data-v-d4486fb7>When a heap dump is first accessed, Jeffrey builds an analysis cache:</p><ol data-v-d4486fb7><li data-v-d4486fb7><strong data-v-d4486fb7>Parsing</strong> - The .hprof file is read and parsed</li><li data-v-d4486fb7><strong data-v-d4486fb7>Indexing</strong> - Objects and references are indexed for fast lookup</li><li data-v-d4486fb7><strong data-v-d4486fb7>Size calculation</strong> - Retained sizes are computed</li><li data-v-d4486fb7><strong data-v-d4486fb7>Cache storage</strong> - Results are stored for subsequent queries</li></ol>",3)),a(n,{type:"warning"},{default:i(()=>[...e[2]||(e[2]=[t("strong",null,"Resource intensive:",-1),s(" Heap dump initialization can be memory and CPU intensive, especially for large heaps. The initialization runs in the background and progress is shown on the overview page. ",-1)])]),_:1}),e[14]||(e[14]=t("h2",{id:"analysis"},"Analysis Features",-1)),e[15]||(e[15]=t("p",null,"Once initialization completes, powerful analysis features become available:",-1)),t("div",z,[a(o,{icon:"bi bi-list-ol",title:"Class Histogram"},{default:i(()=>[...e[3]||(e[3]=[s(" Object counts and memory sizes grouped by class. See which classes consume the most memory and how many instances exist. Sort by instance count, shallow size, or retained size to find memory-heavy classes. ",-1)])]),_:1}),a(o,{icon:"bi bi-fonts",title:"String Analysis"},{default:i(()=>[...e[4]||(e[4]=[s(" Specialized analysis for String objects, which often consume significant heap space. Find duplicate strings, identify long strings, and discover opportunities to reduce memory usage through string deduplication or interning. ",-1)])]),_:1}),a(o,{icon:"bi bi-terminal",title:"OQL Query"},{default:i(()=>[...e[5]||(e[5]=[s(" Object Query Language for custom heap analysis. Write SQL-like queries to find specific objects, filter by field values, and navigate reference chains. Essential for targeted investigation of memory issues. ",-1)])]),_:1})]),e[16]||(e[16]=d("<h3 data-v-d4486fb7>Understanding Memory Sizes</h3><table data-v-d4486fb7><thead data-v-d4486fb7><tr data-v-d4486fb7><th data-v-d4486fb7>Size Type</th><th data-v-d4486fb7>Description</th></tr></thead><tbody data-v-d4486fb7><tr data-v-d4486fb7><td data-v-d4486fb7><strong data-v-d4486fb7>Shallow Size</strong></td><td data-v-d4486fb7>Memory consumed by the object itself (header + fields)</td></tr><tr data-v-d4486fb7><td data-v-d4486fb7><strong data-v-d4486fb7>Retained Size</strong></td><td data-v-d4486fb7>Memory that would be freed if this object were garbage collected (includes referenced objects that would become unreachable)</td></tr></tbody></table>",2)),a(n,{type:"tip"},{default:i(()=>[...e[6]||(e[6]=[t("strong",null,"Finding memory leaks:",-1),s(" Look for objects with high retained size that shouldn't exist. String Analysis is particularly useful for finding wasteful string duplication. ",-1)])]),_:1}),e[17]||(e[17]=t("h2",{id:"details"},"Details",-1)),e[18]||(e[18]=t("p",null,"Advanced heap analysis features for deep investigation:",-1)),t("div",S,[a(o,{icon:"bi bi-diagram-3",title:"GC Roots"},{default:i(()=>[...e[7]||(e[7]=[s(" Browse garbage collection root objects - the starting points for object reachability. Understand what's keeping objects alive by examining the reference chains from GC roots. Essential for diagnosing memory leaks. ",-1)])]),_:1}),a(o,{icon:"bi bi-cpu",title:"Threads"},{default:i(()=>[...e[8]||(e[8]=[s(" Thread stack traces captured at the time of the heap dump, including local variables and their object references. See what each thread was doing and what objects it was holding. ",-1)])]),_:1})]),e[19]||(e[19]=d("<h3 data-v-d4486fb7>GC Roots Categories</h3><p data-v-d4486fb7>Objects can be GC roots for different reasons:</p><ul data-v-d4486fb7><li data-v-d4486fb7><strong data-v-d4486fb7>Thread</strong> - Local variables on active thread stacks</li><li data-v-d4486fb7><strong data-v-d4486fb7>Static Field</strong> - Static fields in loaded classes</li><li data-v-d4486fb7><strong data-v-d4486fb7>JNI Global</strong> - Global references from native code</li><li data-v-d4486fb7><strong data-v-d4486fb7>Monitor</strong> - Objects used as synchronization monitors</li><li data-v-d4486fb7><strong data-v-d4486fb7>System Class</strong> - Core Java classes loaded by the bootstrap classloader</li></ul>",3)),a(n,{type:"info"},{default:i(()=>[...e[9]||(e[9]=[t("strong",null,"Memory leak pattern:",-1),s(" A common memory leak pattern is objects held by static fields or thread-local variables that are never cleared. Check GC Roots to identify unexpected references keeping objects alive. ",-1)])]),_:1}),e[20]||(e[20]=t("p",null,"Heap dump analysis complements JFR-based profiling by providing point-in-time memory snapshots. Use JFR for understanding allocation patterns over time, and heap dumps for detailed investigation of memory contents.",-1))]),a(b)]))}}),A=g(j,[["__scopeId","data-v-d4486fb7"]]);export{A as default};
