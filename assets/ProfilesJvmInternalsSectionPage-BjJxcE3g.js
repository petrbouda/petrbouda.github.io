import{D as o}from"./DocsCallout-CN2pqXu-.js";import{D as s}from"./DocsFeatureItem-D_UHqQjj.js";import{D as u,a as p}from"./DocsPageHeader-BBF35W9f.js";import{u as m}from"./useDocHeadings-By33_tDs.js";import{d as v,i as g,c as b,b as n,a as t,k as f,w as a,m as i,r as c,o as h}from"./index-DrKSq3n4.js";import{_ as y}from"./_plugin-vue_export-helper-DlAUqK2U.js";const w={class:"docs-article"},C={class:"docs-content"},k={class:"docs-feature-list"},J={class:"docs-feature-list"},M={class:"docs-feature-list"},T={class:"docs-feature-list"},V={class:"docs-feature-list"},x={class:"docs-feature-list"},A={class:"docs-feature-list"},I=v({__name:"ProfilesJvmInternalsSectionPage",setup(G){const{setHeadings:l}=m(),d=[{id:"overview",text:"Overview",level:2},{id:"analysis",text:"Analysis",level:2},{id:"events",text:"Events",level:2},{id:"threads",text:"Threads",level:2},{id:"memory",text:"Memory",level:2},{id:"compiler",text:"Compiler",level:2},{id:"infrastructure",text:"Infrastructure",level:2}];return g(()=>{l(d)}),(S,e)=>{const r=c("router-link");return h(),b("article",w,[n(u,{title:"JVM Internals Section",icon:"bi bi-cpu"}),t("div",C,[e[23]||(e[23]=f('<p data-v-b2a500b8>The JVM Internals section provides <strong data-v-b2a500b8>core JVM metrics and analysis</strong> - everything you need to understand how your Java application interacts with the JVM runtime, including memory management, threading, compilation, and configuration.</p><h2 id="overview" data-v-b2a500b8>Overview</h2><p data-v-b2a500b8>This section focuses on JVM-level behavior rather than application-specific logic. It&#39;s the default section when opening a profile and contains the most fundamental analysis tools:</p><ul data-v-b2a500b8><li data-v-b2a500b8><strong data-v-b2a500b8>Configuration review</strong> - JVM settings and recording information</li><li data-v-b2a500b8><strong data-v-b2a500b8>Automated analysis</strong> - Guardian and Auto Analysis for quick insights</li><li data-v-b2a500b8><strong data-v-b2a500b8>Event exploration</strong> - Browse all JFR events captured in the recording</li><li data-v-b2a500b8><strong data-v-b2a500b8>Thread analysis</strong> - Understand thread behavior and state transitions</li><li data-v-b2a500b8><strong data-v-b2a500b8>Memory analysis</strong> - Heap usage and garbage collection patterns</li><li data-v-b2a500b8><strong data-v-b2a500b8>JIT compilation</strong> - Compiler activity and optimizations</li></ul><h2 id="analysis" data-v-b2a500b8>Analysis</h2><p data-v-b2a500b8>The Analysis section provides automated insights and configuration review:</p>',6)),t("div",k,[n(s,{icon:"bi bi-gear",title:"Configuration"},{default:a(()=>[...e[0]||(e[0]=[i(" Displays the profile's configuration including JVM information, recording settings, and system properties. This is your starting point for understanding the environment where the recording was captured. ",-1)])]),_:1}),n(s,{icon:"bi bi-shield-check",title:"Guardian Analysis"},{default:a(()=>[...e[1]||(e[1]=[i(" Automated health checks that traverse stacktraces to find suspicious patterns. Guardian looks for infinite loops, excessive locking, problematic allocations, and other anti-patterns. Results are categorized by severity with a warning badge in the sidebar. ",-1)])]),_:1}),n(s,{icon:"bi bi-robot",title:"Auto Analysis"},{default:a(()=>[...e[2]||(e[2]=[i(" Rule-based automated analysis that examines JFR events and provides color-coded insights (OK, Warning, Critical). Unlike Guardian which focuses on stacktraces, Auto Analysis evaluates event metrics and thresholds. ",-1)])]),_:1}),n(s,{icon:"bi bi-speedometer2",title:"Performance Counters"},{default:a(()=>[...e[3]||(e[3]=[i(" Hardware performance metrics when available. Shows CPU cycles, cache misses, and other low-level counters that can reveal performance bottlenecks not visible at the Java level. ",-1)])]),_:1})]),n(o,{type:"tip"},{default:a(()=>[...e[4]||(e[4]=[t("strong",null,"Quick triage:",-1),i(" Start with Guardian Analysis and Auto Analysis for immediate insights. Warning badges in the sidebar indicate issues that need attention. ",-1)])]),_:1}),e[24]||(e[24]=t("h2",{id:"events"},"Events",-1)),e[25]||(e[25]=t("p",null,"The Events section provides direct access to all JFR events captured in the recording:",-1)),t("div",J,[n(s,{icon:"bi bi-list-check",title:"Event Types"},{default:a(()=>[...e[5]||(e[5]=[i(" Browse all available JFR event types in the recording. See event counts, categories, and which events were enabled during recording. Useful for understanding what data is available for analysis. ",-1)])]),_:1}),n(s,{icon:"bi bi-collection",title:"Event Viewer"},{default:a(()=>[...e[6]||(e[6]=[i(" Filter and search raw event data with comprehensive categorization. Drill down into individual events to see all fields and values. Essential for detailed investigation when other views don't show what you need. ",-1)])]),_:1}),n(s,{icon:"bi bi-flag",title:"JVM Flags"},{default:a(()=>[...e[7]||(e[7]=[i(" View JVM command-line flags and their values. Understand how the JVM was configured - GC settings, heap sizes, experimental features, and diagnostic options. ",-1)])]),_:1})]),e[26]||(e[26]=t("h2",{id:"threads"},"Threads",-1)),e[27]||(e[27]=t("p",null,"Thread analysis helps understand concurrency patterns and identify threading issues:",-1)),t("div",M,[n(s,{icon:"bi bi-graph-up",title:"Statistics"},{default:a(()=>[...e[8]||(e[8]=[i(" Per-thread aggregations showing CPU time, allocations, and state distribution. Identify which threads consume the most resources and how they spend their time. ",-1)])]),_:1}),n(s,{icon:"bi bi-clock-history",title:"Timeline"},{default:a(()=>[...e[9]||(e[9]=[i(" Visual timeline of thread activity over time. See when threads are running, blocked, waiting, or sleeping. Spot patterns like thundering herds, lock convoys, or thread starvation. ",-1)])]),_:1})]),n(o,{type:"info"},{default:a(()=>[...e[10]||(e[10]=[i(" Thread Timeline is particularly useful for identifying synchronization issues and understanding the temporal relationship between thread activities. ",-1)])]),_:1}),e[28]||(e[28]=t("h2",{id:"memory"},"Memory",-1)),e[29]||(e[29]=t("p",null,"Memory analysis covers heap usage and garbage collection behavior:",-1)),e[30]||(e[30]=t("h3",null,"Heap Memory",-1)),t("div",T,[n(s,{icon:"bi bi-graph-up-arrow",title:"Timeseries"},{default:a(()=>[...e[11]||(e[11]=[i(" Memory usage trends over time showing used heap, committed heap, and maximum heap. Identify memory leaks (steadily increasing used heap) or sizing issues (frequent committed heap changes). ",-1)])]),_:1})]),e[31]||(e[31]=t("h3",null,"Garbage Collection",-1)),t("div",V,[n(s,{icon:"bi bi-bar-chart-line",title:"Overview"},{default:a(()=>[...e[12]||(e[12]=[i(" GC pause distribution and statistics. See pause time percentiles, collection counts, and heap reclamation efficiency. Identify if GC is causing latency issues. ",-1)])]),_:1}),n(s,{icon:"bi bi-graph-up-arrow",title:"Timeseries"},{default:a(()=>[...e[13]||(e[13]=[i(" GC activity over time showing pause durations and collection frequency. Correlate GC events with application behavior to understand their impact. ",-1)])]),_:1}),n(s,{icon:"bi bi-gear",title:"Configuration"},{default:a(()=>[...e[14]||(e[14]=[i(" GC algorithm settings and tuning parameters. Review the collector in use (G1, ZGC, Shenandoah, etc.) and its configuration options. ",-1)])]),_:1})]),e[32]||(e[32]=t("h2",{id:"compiler"},"Compiler",-1)),e[33]||(e[33]=t("p",null,"JIT compilation analysis shows how the JVM optimizes your code at runtime:",-1)),t("div",x,[n(s,{icon:"bi bi-lightning",title:"JIT Compilation"},{default:a(()=>[...e[15]||(e[15]=[i(" Method compilation activity including compilation times, code sizes, and optimization levels. Track deoptimizations that may indicate unstable code patterns. Monitor code cache usage to ensure compiled code isn't being evicted. ",-1)])]),_:1})]),e[34]||(e[34]=t("h2",{id:"infrastructure"},"Infrastructure",-1)),e[35]||(e[35]=t("p",null,"Infrastructure analysis is relevant when running in containerized environments:",-1)),t("div",A,[n(s,{icon:"bi bi-server",title:"Container Configuration"},{default:a(()=>[...e[16]||(e[16]=[i(" Container limits and resource quotas when available. Shows CPU limits, memory limits, and how the JVM perceives them. Important for understanding resource constraints in Kubernetes or Docker deployments. ",-1)])]),_:1})]),n(o,{type:"warning"},{default:a(()=>[...e[17]||(e[17]=[t("strong",null,"Feature availability:",-1),i(" Some features like Performance Counters and Container Configuration may be disabled if the recording doesn't contain the required events. Disabled features appear grayed out in the sidebar. ",-1)])]),_:1}),t("p",null,[e[20]||(e[20]=i("For detailed information about specific features, see the ",-1)),n(r,{to:"/docs/features/guardian"},{default:a(()=>[...e[18]||(e[18]=[i("Guardian",-1)])]),_:1}),e[21]||(e[21]=i(" and ",-1)),n(r,{to:"/docs/features/auto-analysis"},{default:a(()=>[...e[19]||(e[19]=[i("Auto Analysis",-1)])]),_:1}),e[22]||(e[22]=i(" documentation.",-1))])]),n(p)])}}}),U=y(I,[["__scopeId","data-v-b2a500b8"]]);export{U as default};
