import{D as s}from"./DocsCallout-DRXeuY10.js";import{D as n,a as f}from"./DocsPageHeader-eA4hMhgw.js";import{u as c}from"./useDocHeadings-CsEjSeXR.js";import{d as v,i as p,c as h,b as t,a,k as d,w as r,m as i,o as g}from"./index-C-iaNavr.js";import{_ as u}from"./_plugin-vue_export-helper-DlAUqK2U.js";const b={class:"docs-article"},m={class:"docs-content"},y=v({__name:"ArchitectureStoragePage",setup(w){const{setHeadings:l}=c(),o=[{id:"design-philosophy",text:"Design Philosophy",level:2},{id:"dual-database-architecture",text:"Dual Database Architecture",level:2},{id:"write-once-read-many",text:"Write-Once-Read-Many for Profiles",level:2},{id:"file-storage",text:"File Storage",level:2}];return p(()=>{l(o)}),(D,e)=>(g(),h("article",b,[t(n,{title:"Storage",icon:"bi bi-database"}),a("div",m,[e[2]||(e[2]=d('<p data-v-a6f21854>Jeffrey uses a unique storage architecture designed for <strong data-v-a6f21854>operational simplicity</strong> and <strong data-v-a6f21854>cost efficiency</strong>. Instead of requiring external database servers, all data is stored in local files using DuckDB.</p><h2 id="design-philosophy" data-v-a6f21854>Design Philosophy</h2><p data-v-a6f21854>The storage design follows several key principles:</p><div class="principles-grid" data-v-a6f21854><div class="principle-card" data-v-a6f21854><div class="card-icon" data-v-a6f21854><i class="bi bi-currency-dollar" data-v-a6f21854></i></div><div class="card-content" data-v-a6f21854><h4 data-v-a6f21854>No External Databases</h4><p data-v-a6f21854>Avoid expensive managed databases. Use in-process DuckDB stored in local files.</p></div></div><div class="principle-card" data-v-a6f21854><div class="card-icon" data-v-a6f21854><i class="bi bi-trash3" data-v-a6f21854></i></div><div class="card-content" data-v-a6f21854><h4 data-v-a6f21854>Fast Deletion</h4><p data-v-a6f21854>Delete a profile instantly by removing a single database file.</p></div></div><div class="principle-card" data-v-a6f21854><div class="card-icon" data-v-a6f21854><i class="bi bi-shield-lock" data-v-a6f21854></i></div><div class="card-content" data-v-a6f21854><h4 data-v-a6f21854>Isolation</h4><p data-v-a6f21854>Each profile has its own database - no contention, no shared state.</p></div></div><div class="principle-card" data-v-a6f21854><div class="card-icon" data-v-a6f21854><i class="bi bi-pencil-square" data-v-a6f21854></i></div><div class="card-content" data-v-a6f21854><h4 data-v-a6f21854>Write Once, Read Many</h4><p data-v-a6f21854>All writes happen during profile initialization. After that, data is read-only.</p></div></div><div class="principle-card" data-v-a6f21854><div class="card-icon" data-v-a6f21854><i class="bi bi-file-zip" data-v-a6f21854></i></div><div class="card-content" data-v-a6f21854><h4 data-v-a6f21854>Compressed Storage</h4><p data-v-a6f21854>JFR files are stored compressed with LZ4, Heap Dumps with GZIP to save disk space.</p></div></div></div><h2 id="dual-database-architecture" data-v-a6f21854>Dual Database Architecture</h2><p data-v-a6f21854>Jeffrey uses two types of DuckDB databases with different purposes:</p><div class="database-diagram" data-v-a6f21854><div class="db-card platform" data-v-a6f21854><div class="card-header" data-v-a6f21854><i class="bi bi-database" data-v-a6f21854></i><h4 data-v-a6f21854>Platform Database</h4><span class="badge" data-v-a6f21854>Single File</span></div><div class="card-body" data-v-a6f21854><p class="file-path" data-v-a6f21854><i class="bi bi-file-earmark" data-v-a6f21854></i> <code data-v-a6f21854>jeffrey.db</code></p><p data-v-a6f21854><strong data-v-a6f21854>Purpose:</strong> Manages workspace, project, and recording metadata</p><h5 data-v-a6f21854>Contains:</h5><ul data-v-a6f21854><li data-v-a6f21854>Workspaces (Sandbox, Live, Remote)</li><li data-v-a6f21854>Projects within workspaces</li><li data-v-a6f21854>Recordings and recording files</li><li data-v-a6f21854>Profile metadata (but NOT event data)</li><li data-v-a6f21854>Scheduler jobs</li><li data-v-a6f21854>Repository sessions</li></ul></div></div><div class="db-card profile" data-v-a6f21854><div class="card-header" data-v-a6f21854><i class="bi bi-database-fill" data-v-a6f21854></i><h4 data-v-a6f21854>Per-Profile Databases</h4><span class="badge" data-v-a6f21854>One Per Profile</span></div><div class="card-body" data-v-a6f21854><p class="file-path" data-v-a6f21854><i class="bi bi-folder" data-v-a6f21854></i> <code data-v-a6f21854>profiles/{id}/profile-data.db</code></p><p data-v-a6f21854><strong data-v-a6f21854>Purpose:</strong> Stores all parsed JFR event data for a single profile</p><h5 data-v-a6f21854>Contains:</h5><ul data-v-a6f21854><li data-v-a6f21854>JFR Events (CPU samples, allocations, locks, etc.)</li><li data-v-a6f21854>Stacktraces and frames</li><li data-v-a6f21854>Thread information</li><li data-v-a6f21854>Event type metadata</li><li data-v-a6f21854>Cache table for analysis results</li></ul></div></div></div>',7)),t(s,{type:"info"},{default:r(()=>[...e[0]||(e[0]=[a("strong",null,"Why separate databases?",-1),a("ul",{style:{margin:"0.5rem 0 0 0","padding-left":"1.25rem"}},[a("li",null,[a("strong",null,"Fast deletion"),i(" - Remove a profile by deleting one file instead of running DELETE queries")]),a("li",null,[a("strong",null,"No contention"),i(" - Profile analysis doesn't block other profiles")]),a("li",null,[a("strong",null,"Simple scaling"),i(" - Each profile is completely independent")]),a("li",null,[a("strong",null,"No complex queries"),i(" - No need for profile_id filtering in every query")])],-1)])]),_:1}),e[3]||(e[3]=d(`<h2 id="write-once-read-many" data-v-a6f21854>Write-Once-Read-Many for Profiles</h2><p data-v-a6f21854>Profile databases follow a strict write-once-read-many (WORM) pattern:</p><div class="worm-diagram" data-v-a6f21854><div class="worm-phase write" data-v-a6f21854><div class="phase-header" data-v-a6f21854><span class="phase-number" data-v-a6f21854>1</span><h4 data-v-a6f21854>Write Phase</h4><span class="phase-badge" data-v-a6f21854>Initialization</span></div><div class="phase-body" data-v-a6f21854><ol data-v-a6f21854><li data-v-a6f21854>Parse JFR file</li><li data-v-a6f21854>Create profile database with schema</li><li data-v-a6f21854>Extract and write events using batch inserts</li><li data-v-a6f21854>Store stacktraces, frames, threads</li><li data-v-a6f21854>Run post-processing (caching)</li><li data-v-a6f21854>Mark profile as enabled</li></ol><p class="phase-note" data-v-a6f21854><i class="bi bi-lightning-charge" data-v-a6f21854></i> Uses DuckDB Appender API for efficient bulk inserts (10,000 events per batch)</p></div></div><div class="worm-arrow" data-v-a6f21854><i class="bi bi-arrow-right" data-v-a6f21854></i></div><div class="worm-phase read" data-v-a6f21854><div class="phase-header" data-v-a6f21854><span class="phase-number" data-v-a6f21854>2</span><h4 data-v-a6f21854>Read Phase</h4><span class="phase-badge" data-v-a6f21854>Analysis</span></div><div class="phase-body" data-v-a6f21854><ul data-v-a6f21854><li data-v-a6f21854>SQL queries for flamegraph data</li><li data-v-a6f21854>Time series aggregations</li><li data-v-a6f21854>Guardian pattern matching</li><li data-v-a6f21854>Thread and GC analysis</li><li data-v-a6f21854>All other analysis features</li></ul><p class="phase-note" data-v-a6f21854><i class="bi bi-lock" data-v-a6f21854></i> No modifications to event data after initialization</p></div></div></div><h3 data-v-a6f21854>Benefits of WORM Pattern</h3><ul data-v-a6f21854><li data-v-a6f21854><strong data-v-a6f21854>Predictable Performance</strong> - No write contention during analysis</li><li data-v-a6f21854><strong data-v-a6f21854>Simplified Caching</strong> - Data never changes, cache is always valid</li><li data-v-a6f21854><strong data-v-a6f21854>Concurrent Access</strong> - Multiple analysis queries can run simultaneously</li><li data-v-a6f21854><strong data-v-a6f21854>Data Integrity</strong> - Original JFR data preserved exactly as parsed</li></ul><h2 id="file-storage" data-v-a6f21854>File Storage</h2><p data-v-a6f21854>JFR recordings and artifacts are stored on the filesystem:</p><div class="directory-structure" data-v-a6f21854><pre data-v-a6f21854><code data-v-a6f21854>$JEFFREY_HOME/
├── jeffrey.db                    # Platform database
├── profiles/
│   ├── {profile-id-1}/
│   │   └── profile-data.db      # Profile database
│   ├── {profile-id-2}/
│   │   └── profile-data.db
│   └── ...
└── workspaces/
    └── {workspace-id}/
        └── {project-id}/
            └── recordings/
                └── {recording-id}/
                    ├── recording.jfr    # Main JFR file
                    └── artifacts/       # Heap dumps, logs, etc.</code></pre></div><h3 data-v-a6f21854>Recording Storage</h3><p data-v-a6f21854>Each recording is stored in its own directory:</p><ul data-v-a6f21854><li data-v-a6f21854><strong data-v-a6f21854>One main recording file</strong> - The JFR file (<code data-v-a6f21854>.jfr</code> or <code data-v-a6f21854>.jfr.lz4</code>)</li><li data-v-a6f21854><strong data-v-a6f21854>Multiple artifacts</strong> - Heap dumps, JVM logs, perf-counters</li></ul>`,11)),t(s,{type:"tip"},{default:r(()=>[...e[1]||(e[1]=[a("strong",null,"Storage efficiency:",-1),i(" JFR files are stored compressed with LZ4 (",-1),a("code",null,".jfr.lz4",-1),i("), Heap Dumps with GZIP (",-1),a("code",null,".hprof.gz",-1),i("). Jeffrey decompresses them automatically during parsing. ",-1)])]),_:1})]),t(f)]))}}),x=u(y,[["__scopeId","data-v-a6f21854"]]);export{x as default};
